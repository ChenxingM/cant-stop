# 🚀 CantStop扩展系统使用指南

本指南介绍如何使用新增的扩展系统来添加自定义成就和陷阱，同时保持系统向后兼容。

## 📋 系统概述

### ✅ 已完成的改进

1. **事件驱动架构** - 自动成就检测
2. **配置文件驱动的成就系统** - 无需修改代码
3. **插件化陷阱系统** - 支持动态扩展
4. **向后兼容** - 现有功能继续正常工作

---

## 🏆 添加新成就

### 方法1：配置文件添加（推荐）

1. **编辑配置文件** `config/achievements.json`：

```json
{
  "achievements": {
    "your_new_achievement": {
      "name": "🎯 您的新成就",
      "description": "成就描述",
      "category": "CHALLENGE",
      "reward_description": "奖励描述",
      "conditions": [
        {
          "type": "event_count",
          "event": "column_completed",
          "count": 5,
          "scope": "lifetime"
        }
      ]
    }
  }
}
```

2. **重启系统** - 成就会自动加载并开始检测

### 支持的条件类型

- **event_count**: 事件计数
  ```json
  {
    "type": "event_count",
    "event": "player_died",  // 事件类型
    "count": 3,              // 触发次数
    "scope": "lifetime"      // 范围：lifetime/session
  }
  ```

- **trap_triggered**: 陷阱触发
  ```json
  {
    "type": "trap_triggered",
    "trap_name": "小小火球术"
  }
  ```

- **single_turn_complete**: 单回合通关
  ```json
  {
    "type": "single_turn_complete"
  }
  ```

### 方法2：代码动态添加

```python
from src.core.achievement_manager import AchievementManager

manager = AchievementManager(use_enhanced_system=True)

# 添加新成就
achievement_data = {
    "name": "🎮 代码成就",
    "description": "通过代码添加的成就",
    "category": "SPECIAL",
    "reward_description": "编程奖励",
    "conditions": [
        {
            "type": "event_count",
            "event": "dice_rolled",
            "count": 100,
            "scope": "lifetime"
        }
    ]
}

# 运行时添加
manager.add_achievement_from_config("code_achievement", achievement_data)

# 保存到配置文件
manager.save_achievement_to_config("code_achievement", achievement_data)
```

---

## 🕳️ 添加新陷阱

### 方法1：配置文件添加（推荐）

1. **编辑配置文件** `config/trap_plugins.json`：

```json
{
  "plugins": {
    "您的新陷阱": {
      "plugin_class": "YourNewTrap",
      "name": "您的新陷阱",
      "description": "陷阱描述",
      "character_quote": "角色台词",
      "penalty_description": "惩罚描述",
      "position_config": {
        "columns": [9, 10],
        "positions": [3, 4]
      },
      "enabled": true
    }
  }
}
```

### 方法2：创建陷阱插件类

1. **创建插件文件** `src/plugins/your_new_trap.py`：

```python
from src.core.trap_plugin_system import TrapPluginBase

class YourNewTrap(TrapPluginBase):
    def __init__(self):
        super().__init__("您的新陷阱", "这是一个新陷阱")

    def get_character_quote(self) -> str:
        return "新陷阱的角色台词"

    def apply_first_time_penalty(self, player_id: str, session_id: str) -> dict:
        return {
            "type": "custom_penalty",
            "description": "首次触发惩罚",
            "score_penalty": 15
        }

    def apply_repeat_penalty(self, player_id: str, session_id: str) -> dict:
        return {
            "type": "score_penalty",
            "description": "重复触发惩罚",
            "amount": 10
        }
```

2. **注册插件**：

```python
from src.core.trap_plugin_system import TrapManager
from src.plugins.your_new_trap import YourNewTrap

manager = TrapManager(use_enhanced_system=True)
plugin = YourNewTrap()
manager.register_plugin("您的新陷阱", plugin)
```

---

## 🔄 事件系统使用

### 发布游戏事件

```python
from src.core.event_system import emit_game_event, GameEventType

# 发布自定义事件
emit_game_event(
    GameEventType.CUSTOM_EVENT,  # 事件类型
    "player_id",                 # 玩家ID
    {                           # 事件数据
        "custom_data": "value",
        "score": 100
    },
    "session_id"                # 会话ID（可选）
)
```

### 监听事件

```python
from src.core.event_system import get_event_system, GameEventType

def my_event_handler(event):
    print(f"收到事件: {event.event_type}, 玩家: {event.player_id}")
    # 处理事件逻辑

event_system = get_event_system()
event_system.subscribe(GameEventType.DICE_ROLLED, my_event_handler)
```

---

## 🔧 集成到现有系统

### 在GameService中使用

```python
# 替换原有的成就系统
from src.core.achievement_manager import AchievementManager

class GameService:
    def __init__(self):
        # 使用增强系统（向后兼容）
        self.achievement_system = AchievementManager(use_enhanced_system=True)
        # 原有接口继续工作
        achievements = self.achievement_system.get_all_achievements()
```

### 在游戏引擎中发布事件

```python
# 在关键游戏操作后发布事件
def roll_dice(self, session_id: str):
    # ... 原有逻辑 ...

    # 发布事件（自动触发成就检测）
    emit_game_event(GameEventType.DICE_ROLLED, player_id, {
        "dice_results": dice_results,
        "combinations": combinations
    })
```

---

## 📊 实际使用示例

### 示例1：添加"幸运星"成就

```json
{
  "achievements": {
    "lucky_star": {
      "name": "⭐ 幸运星",
      "description": "连续5次掷出6个相同数字",
      "category": "CHALLENGE",
      "reward_description": "幸运符咒 - 下次掷骰结果+1",
      "conditions": [
        {
          "type": "consecutive_same_dice",
          "count": 5
        }
      ]
    }
  }
}
```

### 示例2：添加"传送门"陷阱

```json
{
  "plugins": {
    "传送门": {
      "plugin_class": "TeleportTrap",
      "name": "传送门",
      "description": "神秘的传送门将你传送到随机位置",
      "character_quote": "欢迎来到...等等，这是哪？",
      "penalty_description": "随机传送：将一个临时标记移动到随机列的随机位置",
      "position_config": {
        "columns": [6, 7, 14, 15],
        "positions": []
      },
      "enabled": true
    }
  }
}
```

---

## ⚡ 快速开始

1. **添加新成就**（最简单）：
   - 编辑 `config/achievements.json`
   - 重启系统

2. **添加新陷阱**（需要编程）：
   - 编辑 `config/trap_plugins.json`
   - 创建插件类
   - 注册插件

3. **自定义事件**：
   - 在游戏逻辑中调用 `emit_game_event`
   - 设置对应的成就条件

---

## 🛡️ 向后兼容保证

- ✅ 所有现有成就继续正常工作
- ✅ 所有现有陷阱继续正常工作
- ✅ 原有的API接口保持不变
- ✅ 数据库结构无需修改
- ✅ 可以选择使用原系统或增强系统

---

## 🔍 故障排除

### 常见问题

1. **新成就不触发**
   - 检查JSON语法是否正确
   - 确认事件类型名称正确
   - 查看控制台是否有错误信息

2. **陷阱插件无法加载**
   - 确认插件类继承了 `TrapPluginBase`
   - 检查配置文件路径
   - 确认所有必要方法已实现

3. **事件不被处理**
   - 确认使用了增强系统
   - 检查事件订阅是否正确
   - 查看事件历史记录

### 调试工具

```python
# 查看事件历史
from src.core.event_system import get_event_system
event_system = get_event_system()
events = event_system.get_player_events("player_id")
print("玩家事件:", events)

# 检查成就状态
manager = AchievementManager()
unlocked = manager.get_unlocked_achievements()
print("已解锁成就:", [a.name for a in unlocked])
```

---

## 🎯 最佳实践

1. **成就设计**：
   - 条件明确，易于理解
   - 奖励有意义且平衡
   - 分类合适

2. **陷阱设计**：
   - 惩罚有趣但不过分
   - 首次和重复惩罚区别明显
   - 角色台词幽默

3. **事件使用**：
   - 在合适的时机发布事件
   - 事件数据完整
   - 避免过度发布事件

4. **配置管理**：
   - 定期备份配置文件
   - 使用版本控制
   - 测试配置变更

现在您可以轻松扩展游戏内容而无需修改核心代码！🎮